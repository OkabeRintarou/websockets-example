name: Custom Client Count Test

on:
  workflow_dispatch:
    inputs:
      client_count:
        description: 'Number of clients to start (1-10)'
        required: true
        default: '3'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '5'
          - '10'
      load_balancing_strategy:
        description: 'Load balancing strategy'
        required: true
        default: 'least_loaded'
        type: choice
        options:
          - 'least_loaded'
          - 'round_robin'
          - 'weighted_random'
          - 'random'

jobs:
  test-custom:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install websockets
    
    - name: Create orchestrator script
      run: |
        cat > orchestrator.py << 'EOFINNER'
        import asyncio
        import subprocess
        import sys
        import time
        
        class ProcessOrchestrator:
            def __init__(self, client_count, lb_strategy):
                self.client_count = client_count
                self.lb_strategy = lb_strategy
                self.server_proc = None
                self.client_procs = []
                
            async def start_server(self):
                print("🚀 启动 WebSocket Server...")
                print(f"   负载均衡策略: {self.lb_strategy}")
                
                # 修改 server.py 中的负载均衡策略
                with open('server.py', 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # 替换负载均衡策略
                import re
                content = re.sub(
                    r'lb_strategy\s*=\s*"[^"]*"',
                    f'lb_strategy="{self.lb_strategy}"',
                    content
                )
                
                with open('server.py', 'w', encoding='utf-8') as f:
                    f.write(content)
                
                self.server_proc = subprocess.Popen(
                    ["python", "server.py"],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    bufsize=1
                )
                print(f"  ✅ Server PID: {self.server_proc.pid}")
                await asyncio.sleep(3)
                
            async def start_clients(self):
                print(f"\n🚀 启动 {self.client_count} 个 Clients...")
                for i in range(self.client_count):
                    proc = subprocess.Popen(
                        ["python", "client.py"],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        text=True,
                        bufsize=1
                    )
                    self.client_procs.append(proc)
                    print(f"  ✅ Client #{i+1} PID: {proc.pid}")
                    await asyncio.sleep(1)
                
            async def monitor(self, duration=20):
                print(f"\n⏱️  监控运行状态 ({duration} 秒)...")
                start_time = time.time()
                
                while time.time() - start_time < duration:
                    await asyncio.sleep(5)
                    
                    if self.server_proc.poll() is not None:
                        print("❌ Server 已停止")
                        return False
                    
                    alive_clients = sum(1 for p in self.client_procs if p.poll() is None)
                    print(f"  📊 Server: 运行中 | Clients: {alive_clients}/{self.client_count} 活跃")
                
                return True
                
            async def cleanup(self):
                print("\n🧹 清理所有进程...")
                
                for i, proc in enumerate(self.client_procs):
                    if proc.poll() is None:
                        proc.terminate()
                        print(f"  停止 Client #{i+1}")
                
                await asyncio.sleep(1)
                
                if self.server_proc and self.server_proc.poll() is None:
                    self.server_proc.terminate()
                    print("  停止 Server")
                
                await asyncio.sleep(2)
                
                for proc in self.client_procs:
                    if proc.poll() is None:
                        proc.kill()
                
                if self.server_proc and self.server_proc.poll() is None:
                    self.server_proc.kill()
                
                print("✅ 清理完成")
                
            async def run(self):
                try:
                    await self.start_server()
                    await self.start_clients()
                    
                    print("\n⏳ 等待连接建立...")
                    await asyncio.sleep(5)
                    
                    success = await self.monitor(duration=20)
                    
                    if success:
                        print("\n✅ 测试成功完成")
                        return 0
                    else:
                        print("\n❌ 测试失败")
                        return 1
                        
                except Exception as e:
                    print(f"\n❌ 错误: {e}")
                    import traceback
                    traceback.print_exc()
                    return 1
                finally:
                    await self.cleanup()
        
        async def main():
            client_count = int(sys.argv[1]) if len(sys.argv) > 1 else 3
            lb_strategy = sys.argv[2] if len(sys.argv) > 2 else "least_loaded"
            orchestrator = ProcessOrchestrator(client_count, lb_strategy)
            exit_code = await orchestrator.run()
            sys.exit(exit_code)
        
        if __name__ == "__main__":
            asyncio.run(main())
        EOFINNER
    
    - name: Run orchestrated test
      run: |
        echo "📋 测试配置:"
        echo "  - Clients: ${{ github.event.inputs.client_count }}"
        echo "  - Strategy: ${{ github.event.inputs.load_balancing_strategy }}"
        echo ""
        
        python orchestrator.py ${{ github.event.inputs.client_count }} ${{ github.event.inputs.load_balancing_strategy }}
    
    - name: Summary
      if: always()
      run: |
        echo "## Test Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Clients**: ${{ github.event.inputs.client_count }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Strategy**: ${{ github.event.inputs.load_balancing_strategy }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: Completed" >> $GITHUB_STEP_SUMMARY
