name: Custom Client Count Test

on:
  workflow_dispatch:
    inputs:
      client_count:
        description: 'Number of clients to start (1-10)'
        required: true
        default: '3'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '5'
          - '10'
      load_balancing_strategy:
        description: 'Load balancing strategy'
        required: true
        default: 'least_loaded'
        type: choice
        options:
          - 'least_loaded'
          - 'round_robin'
          - 'weighted_random'
          - 'random'

jobs:
  test-custom:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install websockets
    
    - name: Create orchestrator script
      run: |
        cat > orchestrator.py << 'EOFINNER'
        import asyncio
        import subprocess
        import sys
        import time
        
        class ProcessOrchestrator:
            def __init__(self, client_count, lb_strategy):
                self.client_count = client_count
                self.lb_strategy = lb_strategy
                self.server_proc = None
                self.client_procs = []
                
            async def start_server(self):
                print("ðŸš€ å¯åŠ¨ WebSocket Server...")
                print(f"   è´Ÿè½½å‡è¡¡ç­–ç•¥: {self.lb_strategy}")
                
                # ä¿®æ”¹ server.py ä¸­çš„è´Ÿè½½å‡è¡¡ç­–ç•¥
                with open('server.py', 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # æ›¿æ¢è´Ÿè½½å‡è¡¡ç­–ç•¥
                import re
                content = re.sub(
                    r'lb_strategy\s*=\s*"[^"]*"',
                    f'lb_strategy="{self.lb_strategy}"',
                    content
                )
                
                with open('server.py', 'w', encoding='utf-8') as f:
                    f.write(content)
                
                self.server_proc = subprocess.Popen(
                    ["python", "server.py"],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    bufsize=1
                )
                print(f"  âœ… Server PID: {self.server_proc.pid}")
                await asyncio.sleep(3)
                
            async def start_clients(self):
                print(f"\nðŸš€ å¯åŠ¨ {self.client_count} ä¸ª Clients...")
                for i in range(self.client_count):
                    proc = subprocess.Popen(
                        ["python", "client.py"],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        text=True,
                        bufsize=1
                    )
                    self.client_procs.append(proc)
                    print(f"  âœ… Client #{i+1} PID: {proc.pid}")
                    await asyncio.sleep(1)
                
            async def monitor(self, duration=20):
                print(f"\nâ±ï¸  ç›‘æŽ§è¿è¡ŒçŠ¶æ€ ({duration} ç§’)...")
                start_time = time.time()
                
                while time.time() - start_time < duration:
                    await asyncio.sleep(5)
                    
                    if self.server_proc.poll() is not None:
                        print("âŒ Server å·²åœæ­¢")
                        return False
                    
                    alive_clients = sum(1 for p in self.client_procs if p.poll() is None)
                    print(f"  ðŸ“Š Server: è¿è¡Œä¸­ | Clients: {alive_clients}/{self.client_count} æ´»è·ƒ")
                
                return True
                
            async def cleanup(self):
                print("\nðŸ§¹ æ¸…ç†æ‰€æœ‰è¿›ç¨‹...")
                
                for i, proc in enumerate(self.client_procs):
                    if proc.poll() is None:
                        proc.terminate()
                        print(f"  åœæ­¢ Client #{i+1}")
                
                await asyncio.sleep(1)
                
                if self.server_proc and self.server_proc.poll() is None:
                    self.server_proc.terminate()
                    print("  åœæ­¢ Server")
                
                await asyncio.sleep(2)
                
                for proc in self.client_procs:
                    if proc.poll() is None:
                        proc.kill()
                
                if self.server_proc and self.server_proc.poll() is None:
                    self.server_proc.kill()
                
                print("âœ… æ¸…ç†å®Œæˆ")
                
            async def run(self):
                try:
                    await self.start_server()
                    await self.start_clients()
                    
                    print("\nâ³ ç­‰å¾…è¿žæŽ¥å»ºç«‹...")
                    await asyncio.sleep(5)
                    
                    success = await self.monitor(duration=20)
                    
                    if success:
                        print("\nâœ… æµ‹è¯•æˆåŠŸå®Œæˆ")
                        return 0
                    else:
                        print("\nâŒ æµ‹è¯•å¤±è´¥")
                        return 1
                        
                except Exception as e:
                    print(f"\nâŒ é”™è¯¯: {e}")
                    import traceback
                    traceback.print_exc()
                    return 1
                finally:
                    await self.cleanup()
        
        async def main():
            client_count = int(sys.argv[1]) if len(sys.argv) > 1 else 3
            lb_strategy = sys.argv[2] if len(sys.argv) > 2 else "least_loaded"
            orchestrator = ProcessOrchestrator(client_count, lb_strategy)
            exit_code = await orchestrator.run()
            sys.exit(exit_code)
        
        if __name__ == "__main__":
            asyncio.run(main())
        EOFINNER
    
    - name: Run orchestrated test
      run: |
        echo "ðŸ“‹ æµ‹è¯•é…ç½®:"
        echo "  - Clients: ${{ github.event.inputs.client_count }}"
        echo "  - Strategy: ${{ github.event.inputs.load_balancing_strategy }}"
        echo ""
        
        python orchestrator.py ${{ github.event.inputs.client_count }} ${{ github.event.inputs.load_balancing_strategy }}
    
    - name: Summary
      if: always()
      run: |
        echo "## Test Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Clients**: ${{ github.event.inputs.client_count }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Strategy**: ${{ github.event.inputs.load_balancing_strategy }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: Completed" >> $GITHUB_STEP_SUMMARY
