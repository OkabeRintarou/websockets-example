name: WebSocket Client Test (Remote Server)

on:
  push:
    branches: [ main, master, dev ]
  pull_request:
    branches: [ main, master, dev ]
  workflow_dispatch:
    inputs:
      server_host:
        description: 'Server Host (留空则使用 Secrets)'
        required: false
        type: string
      server_port:
        description: 'Server Port (留空则使用 Secrets)'
        required: false
        type: string
  schedule:
    # 北京时间 9:20 (UTC 时间 1:20)
    - cron: '20 1 * * *'
    # 北京时间 11:10 (UTC 时间 3:10)
    - cron: '10 3 * * *'

jobs:
  test-websocket:
    runs-on: ${{ matrix.os }}
    timeout-minutes: 200
    
    strategy:
      matrix:
        os: [ubuntu-22.04, ubuntu-24.04]
        python-version: ['3.9', '3.10', '3.11', '3.12']
    
    steps:
    - name: Checkout code 📦
      uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }} 🐍
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies ⚙️
      run: |
        python -m pip install --upgrade pip
        git clone https://${{ secrets.CLONE_QUOTIENT }}@github.com/trades-platform/quotient.git
        pip install ./quotient
        pip install websockets
    
    - name: Configure remote server settings 🛠️
      env:
        INPUT_SERVER_HOST: ${{ github.event.inputs.server_host }}
        INPUT_SERVER_PORT: ${{ github.event.inputs.server_port }}
        SECRET_SERVER_HOST: ${{ secrets.WEBSOCKET_SERVER_HOST }}
        SECRET_SERVER_PORT: ${{ secrets.WEBSOCKET_SERVER_PORT }}
      run: |
        if [ -n "$SECRET_SERVER_HOST" ]; then
          SERVER_HOST="$SECRET_SERVER_HOST"
          echo "✅ Using Secret: WEBSOCKET_SERVER_HOST"
        elif [ -n "$INPUT_SERVER_HOST" ]; then
          SERVER_HOST="$INPUT_SERVER_HOST"
          echo "✅ Using manual input Host"
        else
          SERVER_HOST="localhost"
          echo "⚠️  Using default Host: localhost"
        fi
        
        if [ -n "$SECRET_SERVER_PORT" ]; then
          SERVER_PORT="$SECRET_SERVER_PORT"
          echo "✅ Using Secret: WEBSOCKET_SERVER_PORT"
        elif [ -n "$INPUT_SERVER_PORT" ]; then
          SERVER_PORT="$INPUT_SERVER_PORT"
          echo "✅ Using manual input Port"
        else
          SERVER_PORT="8765"
          echo "⚠️  Using default Port: 8765"
        fi
        
        echo "SERVER_HOST=$SERVER_HOST" >> $GITHUB_ENV
        echo "SERVER_PORT=$SERVER_PORT" >> $GITHUB_ENV
    
    - name: Test server connectivity 🌐
      run: |
        echo "🔍 Testing server connectivity: $SERVER_HOST:$SERVER_PORT"
        python << 'PYEOF'
        import socket
        import sys
        import os
        
        host = os.environ.get('SERVER_HOST', 'localhost')
        port = int(os.environ.get('SERVER_PORT', '8765'))
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((host, port))
            sock.close()
            
            if result == 0:
                print('✅ Server accessible')
            else:
                print('⚠️  Cannot connect to server')
        except Exception as e:
            print(f'⚠️  Connection test failed: {e}')
        PYEOF
    
    - name: Start client and monitor output 🚀
      run: |
        # Read test duration from GitHub Variables (in minutes), default to 5 minutes
        TEST_DURATION_MINUTES=${{ vars.TEST_DURATION || '5' }}
        TEST_DURATION=$((TEST_DURATION_MINUTES * 60))  # Convert to seconds
        INTERVAL=60
        ELAPSED=0
        
        echo "🚀 Starting client for ${TEST_DURATION_MINUTES} minutes (${TEST_DURATION} seconds)"
        echo "🔗 Connecting to: ws://$SERVER_HOST:$SERVER_PORT"
        
        # Start client and save output to file
        python client.py $SERVER_HOST $SERVER_PORT > client_output.log 2>&1 &
        CLIENT_PID=$!
        echo "CLIENT_PID=$CLIENT_PID" >> $GITHUB_ENV
        echo "⏱️  Will run for ${TEST_DURATION_MINUTES} minutes"
        
        # Start background tail process to continuously show output
        tail -f client_output.log &
        TAIL_PID=$!
        
        # Monitor client status
        while [ $ELAPSED -lt $TEST_DURATION ]; do
          sleep $INTERVAL
          ELAPSED=$((ELAPSED + INTERVAL))
          
          HOURS=$((ELAPSED / 3600))
          MINUTES=$(((ELAPSED % 3600) / 60))
          
          if ! ps -p $CLIENT_PID > /dev/null; then
            # Kill tail process
            kill $TAIL_PID 2>/dev/null || true
            echo "❌ Client stopped after ${HOURS}h ${MINUTES}m"
            echo "📜 Final client output:"
            cat client_output.log
            exit 1
          fi
          
          echo "✅ Client running for ${HOURS}h ${MINUTES}m"
        done
        
        # Kill tail process and show final status
        kill $TAIL_PID 2>/dev/null || true
        echo ""
        echo "✅ Test completed successfully after ${TEST_DURATION_MINUTES} minutes"
        echo "📜 Complete client output:"
        cat client_output.log
    
    - name: Cleanup 🧹
      if: always()
      run: |
        if ps -p $CLIENT_PID > /dev/null 2>&1; then
          kill $CLIENT_PID || true
          echo "✅ Client stopped"
        fi
        if [ -f client_output.log ]; then
          rm client_output.log
          echo "🗑️  Log file cleaned up"
        fi